%%me=0 student solutions, me=1 - my solutions, me=2 - assignment
\def\me{0}
\def\num{8}  %homework number
\def\due{Wednesday, November 12}  %due date
\def\course{CSCI-GA.1170-001/002 Fundamental Algorithms} %course name
\def\name{Keeyon Ebrahimi}
%
\iffalse
INSTRUCTIONS: replace # by the homework number.
(if this is not ps#.tex, use the right file name)

  Clip out the ********* INSERT HERE ********* bits below and insert
appropriate TeX code.  Once you are done with your file, run

  ``latex ps#.tex''

from a UNIX prompt.  If your LaTeX code is clean, the latex will exit
back to a prompt.  To see intermediate results, type

  ``xdvi ps#.dvi'' (from UNIX prompt)
  ``yap ps#.dvi'' (if using MikTex in Windows)

after compilation. Once you are done, run

  ``dvips ps#.dvi''

which should print your file to the nearest printer.  There will be
residual files called ps#.log, ps#.aux, and ps#.dvi.  All these can be
deleted, but do not delete ps1.tex. To generate postscript file ps#.ps,
run

  ``dvips -o ps#.ps ps#.dvi''

I assume you know how to print .ps files (``lpr -Pprinter ps#.ps'')
\fi
%
\documentclass[11pt]{article}
\usepackage{amsfonts,amsmath}
\usepackage{latexsym}
\setlength{\oddsidemargin}{.0in}
\setlength{\evensidemargin}{.0in}
\setlength{\textwidth}{6.5in}
\setlength{\topmargin}{-0.4in}
\setlength{\textheight}{8.5in}

\newcommand{\handout}[5]{
   \renewcommand{\thepage}{#1, Page \arabic{page}}
   \noindent
   \begin{center}
   \framebox{
      \vbox{
    \hbox to 5.78in { {\bf \course} \hfill #2 }
       \vspace{4mm}
       \hbox to 5.78in { {\Large \hfill #5  \hfill} }
       \vspace{2mm}
       \hbox to 5.78in { {\it #3 \hfill #4} }
      }
   }
   \end{center}
   \vspace*{4mm}
}

\newcounter{pppp}
\newcommand{\prob}{\arabic{pppp}}  %problem number
\newcommand{\increase}{\addtocounter{pppp}{1}}  %problem number

%first argument desription, second number of points
\newcommand{\newproblem}[2]{
\ifnum\me=0
\ifnum\prob>0 \newpage \fi
\increase
\setcounter{page}{1}
\handout{\name, Homework \num, Problem \arabic{pppp}}{\today}{Name: \name}{Due:
\due}{Solutions to Problem \prob\ of Homework \num\ (#2)}
\else
\increase
\section*{Problem \num-\prob~(#1) \hfill {#2}}
\fi
}

%\newcommand{\newproblem}[2]{\increase
%\section*{Problem \num-\prob~(#1) \hfill {#2}}
%}

\def\squarebox#1{\hbox to #1{\hfill\vbox to #1{\vfill}}}
\def\qed{\hspace*{\fill}
        \vbox{\hrule\hbox{\vrule\squarebox{.667em}\vrule}\hrule}}
\newenvironment{solution}{\begin{trivlist}\item[]{\bf Solution:}}
                      {\qed \end{trivlist}}
\newenvironment{solsketch}{\begin{trivlist}\item[]{\bf Solution Sketch:}}
                      {\qed \end{trivlist}}
\newenvironment{code}{\begin{tabbing}
12345\=12345\=12345\=12345\=12345\=12345\=12345\=12345\= \kill }
{\end{tabbing}}

%\newcommand{\eqref}[1]{Equation~(\ref{eq:#1})}

\newcommand{\hint}[1]{({\bf Hint}: {#1})}
%Put more macros here, as needed.
\newcommand{\room}{\medskip\ni}
\newcommand{\brak}[1]{\langle #1 \rangle}
\newcommand{\bit}[1]{\{0,1\}^{#1}}
\newcommand{\zo}{\{0,1\}}
\newcommand{\C}{{\cal C}}

\newcommand{\nin}{\not\in}
\newcommand{\set}[1]{\{#1\}}
\renewcommand{\ni}{\noindent}
\renewcommand{\gets}{\leftarrow}
\renewcommand{\to}{\rightarrow}
\newcommand{\assign}{:=}

\newcommand{\AND}{\wedge}
\newcommand{\OR}{\vee}

\newcommand{\For}{\mbox{\bf For }}
\newcommand{\To}{\mbox{\bf to }}
\newcommand{\Do}{\mbox{\bf Do }}
\newcommand{\If}{\mbox{\bf If }}
\newcommand{\Then}{\mbox{\bf Then }}
\newcommand{\Else}{\mbox{\bf Else }}
\newcommand{\While}{\mbox{\bf While }}
\newcommand{\Repeat}{\mbox{\bf Repeat }}
\newcommand{\Until}{\mbox{\bf Until }}
\newcommand{\Return}{\mbox{\bf Return }}


\begin{document}

\ifnum\me=0
%\handout{PS\num}{\today}{Name: **** INSERT YOU NAME HERE ****}{Due:
%\due}{Solutions to Problem Set \num}
%
%I collaborated with *********** INSERT COLLABORATORS HERE (INDICATING
%SPECIFIC PROBLEMS) *************.
\fi
\ifnum\me=1
\handout{PS\num}{\today}{Name: Yevgeniy Dodis}{Due: \due}{Solution
{\em Sketches} to Problem Set \num}
\fi
\ifnum\me=2
\handout{PS\num}{\today}{Lecturer: Yevgeniy Dodis}{Due: \due}{Problem
Set \num}
\fi

\newproblem{Not All Greedy are Equal}{3(+5) points}

For each of the following suggested greedy algorithms for the {\sc
Activity-Selection} problem, give a simple example of the input where
the proposed greedy algorithm fails to compute the correct optimal
solution.

\begin{itemize}

\item[(a)] (3 points) Select the activity $a_i$ with the shortest duration $d_i =
f_i-s_i$. Commit to scheduling $a_i$. Let $S_i'$ consist of all
activities $a_j$ which do not overlap with $a_i$: namely, either
$f_j\le s_i$ or $f_i\le s_j$. Recursively solve {\sc
Activity-Selection} on $S_i'$, scheduling the resulting activities
together with $a_i$.

\ifnum\me<2
\begin{solution} \\ \\
This greedy approach will fail if the shortest activity disqualifies 2 other disjoint activities by overlapping both.  Here is an example of this type of problem. \\ \\
\begin{tabular}{l*{6}{c}r}
$i$              & 1 & 2 & 3 & 4 & 5 \\
\hline
$si$ 		& 1 & 9 & 10 & 18 & 20  \\
$fi$            & 10 & 12 & 20 & 22 &  34  \\
\end{tabular}

In this example, the first block that will be picked is $a_2$, for it has the shortest duration of $3$.  The selection of $a_2$ disqualifies $a_1$ and $a_3$, for they have intersecting start and end times.  The next shortest time will then be $a_4$ with a total time of $4$.  This will then disqualify $a_5$, which then in total gives this greedy algorithm a total of 2 activities.
\\ \\
We can see though that is is not the optimal, for the optimal is actually $a_1\cup a_3 \cup a_5$\\  This has a total of 3 activities, while the previously suggested greedy algorithm only gives 2 activities.
\end{solution}
\fi

\item[(b)$^*$] {\bf (Extra Credit; 5 points)} For each activity $a_i$, let $n_i$
denote the number of activities which do not overlap with $a_i$ (e.g.,
$n_i$ is the cardinality of the set $S_i'$ defined above for specific
$a_i$). Select the activity $a_i$ with the largest number $n_i$ of
non-overlapping activities. Commit to scheduling $a_i$. Recursively
solve {\sc Activity-Selection} on the $n_i$ activities in $S_i'$,
scheduling the resulting activities together with $a_i$.\\
\hint{Unlike part (a), you might need a lot of activities for this
counter-example. The smallest I know uses $n=11$ activities. So don't
be discouraged if small examples are all bad.}

\ifnum\me<2
\begin{solution}

\end{solution}
\fi

\end{itemize}


\newproblem{Arranging Books on  Book Shelves}{11 Points}

Consider the problem of storing $n$ books on shelves in a library. The
order of the books is fixed by the cataloging system and so cannot be
rearranged. The $i$-th book $b_i$, where $1 \leq i \leq n$ has a
thickness $t_i$ and height $h_i$ stored in arrays $t[1 \ldots n]$ and
$h[1 \ldots n]$. The length of each bookshelf at this library is $L$. We
want to minimize the sum of heights of the shelves needed to arrange
these books.

\begin{itemize}
\item[(a)] (5 points) Suppose all the books have the same height $h$
  (i.e., $h = h_i$ for all $i$) and the shelves are each of height
  $h$, so any book fits on any shelf. The greedy algorithm would fill
  the first shelf with as many books as we can until we get the
  smallest $i$ such that $b_i$ does not fit, and then repeat with
  subsequent shelves. Using either the Greedy Always Stays Ahead or Local Swap method, show that the greedy algorithm always finds the   shelf placement with the smallest total height of shelves, and
  analyze its time complexity.

\ifnum\me<2
\begin{solution}
\\
With a constant height for all shelves, we have this equation for the Total Shelve Height.\\
$S = $ Number of Shelves\\
$h = $ constant\\
$TotalHeight = h * S$\\
Because $h$ is constant, we need to minimize $S$ to get the minimal $TotalHeight$\\ \\

\textbf{Proof by GASA}\\
$b_m = $ total number of books on shelf\\
$b_i(g)$ = $i$ books on shelf in greedy approach\\
$b_i(z)$ = $i$ books on shelf in optimal approach \\
$S_i$ = Amount of shelves needed with $i$ books.\\
\\
First we will be showing that the approach of if it fits it sits puts the maximum books on a shelf.\\
\begin{enumerate}
\item[1. ] $b_1(g) \geq b_1(z)$  \\ \\ We know this by definition.  If the first book fits, it sits. Which has atleast as many as the optimal, because there is no greater for 1.\\
\item[2. ] $b_m(g) \geq b_m(z)$ \\ \\ If this happens with one, this happens with $m$ as well.\\
\item[3. ] $b_{m+1}(z) \geq b_m(g) \geq b_m(z)$\\
\item[4. ] $b_{m+1}(g) \geq b_{m+1}(z)$\\ 
\end{enumerate}
This shows that we can fit the most books on the shelf by going with the approach, if it fits it sits.
\\\\
Now we know $$totalBooks = BooksOnShelves + BooksRemaining$$\\

Because $totalBooks$ is constant, the greater $BooksOnShelves$ is, the smaller $BooksRemaining$ will be.  We have proven that our greedy approach gives the maximum $BooksOnShelves$, so we know need to prove that a smaller $BooksRemaining$ leads to smaller $TotalShelves$
\\ \\
Lets set $S_i$ to be the total number of shelves it takes to store $i$ books.  By laws of nature we know that $S_1 \leq S_2 \leq ... \leq S_n$\\

\textbf{We know that we have given the least remaining books with our greedy algorithm, which in turn has the least amount of shelves as shown directly above this, and we also know that the less Shelves we have the less our Total height will be, so with all this we know that our greedy algorithm gives the optimal number of shelves.} \\ 

\textbf{Running Time: } All we have to do here is at every book, see if it will fit or not and then either place on existing shelf or next shelf.  We only have to iterate through each book once in order to do this for all books, so because we only iterate through all books once, we know that we have a running time of $$O(n)$$
\end{solution}
\fi

\item[(b)] (6 points) Now assume that the books are not of the same
  height, and hence the height of any shelf is set to be the height of
  the largest book placed on that shelf. Show that the greedy
  algorithm in part (a) doesn't work for this problem. Give an
  alternative dynamic programming algorithm to solve this
  problem. What is the running time of your algorithm?

\ifnum\me<2
\begin{solution}
\\Here is an example of when this will not work.\\  Lets say he have two heights, $B$ for tall and $b$ for short.  \\ \\

Let say our greedy algorithm first whatever we can and we get 2 shelves shaped like this.\\ \\
\begin{tabular}{l*{6}{c}r}
$Shelf\ 1$ 		& $b$ & $b$ & $b$ & $B$   \\
$Shelf\ 2$         & $B$  \\
\end{tabular}
\\ \\ \\
The tallest in both shelves is $B$, so the total height would be $2B$.\\
There is a better solution though. What if we placed the $B$ at the end of shelf on on the next shelf.  We would get this solution. \\ \\
\begin{tabular}{l*{6}{c}r}
$Shelf\ 1$ 		& $b$ & $b$ & $b$   \\
$Shelf\ 2$         & $B$  & $B$ \\
\end{tabular}\\ \\ \\
Which gives us a total Height of $b + B$, which is less than $B+B$, so the greedy approach is not optimal.
\\ \\ 
Here is the algorithm to figure out the best solution.
We set up a Memoization Array $TH$ with $TH[0] = 0$ and $TH[1..n]$ = infinity.\\ \\
If the next book will not fit on the current shelf, we put it on the next Shelf.  \ \\\
If the book does fit, then we must look at the books height vs the Current Shelf Height.
If book height, $h[i]$ is less than Current Shelf Height,  then we just place the book on the shelf. \\ \\

If the book height does fit, but it's height is greater than the current Row Height. We have to make a decision. \\
We pick $Min($Placing book on current shelf, Placing book on next shelf$)$, which is where the recursion and memoization come in to help.\\

This will have a running time of $O(n^2)$, which is significantly better than the $2^n$ running time we would usually have if we didn't use memoization.  It is $n^2$ because for each problem n, we have to look at all previous books and check if it is better for them to go on the current row or to start a new row off.

\end{solution}
\fi

\end{itemize}

\newproblem{Frugal Tourist}{12 Points}

You want to travel on a straight line from from city $A$ to city $B$
which is $N$ miles away from $A$. For concreteness, imagine a line
with $A$ being at $0$ and $B$ being at $N$. Each day you can travel at
most $d$ miles (where $0<d<N$), after which you need to stay at an
expensive hotel. There are $n$ such hotels between $0$ and $N$,
located at points $0 <a_1<a_2<\ldots < a_n = N$ (the last hotel is in
$B$). Luckily, you know that $|a_{i+1}-a_i|\le d$ for any $i$ (with
$a_0=0$), so that you can at least travel to the next hotel in one
day. You goal is to complete your travel in the smallest number of
days (so that you do not pay a fortune for the hotels).

Consider the following greedy algorithm: ``Each day, starting at the
current hotel $a_i$, travel to the furthest hotel $a_j$
s.t. $|a_j-a_i|\le d$, until eventually $a_n=N$ is reached''. I.e., if
several hotels are within reach in one day from your current position,
go to the one closest to your destination.

\begin{itemize}
\item[(a)] (6 points) Formally argue that this algorithm is correct using the
``Greedy Stays Ahead'' method.\\
\hint{Think how to define $F_i(Z)$.
For this problem, the name of the method is really appropriate.}

\ifnum\me<2
\begin{solution}
\textbf{Proof by GASA}\\
$h_i(g) = i$ Hotel number Visited on Day $i$ by Greedy Solution
$h_i(z) = i$ Hotel number visited on Day $i$ by optimal solution
\\ \\
\begin{enumerate}
\item[1. ] $a_1(g) \geq a_1(z)$ \\ \\
We know this because of definition.  We go to the furthest one each day in the greedy approach, so we go the the furthest, so greedy $\geq$ optimal for day 1.\\
\item[2. ] $a_m(g) \geq a_m(z)$ \\ \\
Same logic as step 1.  If we know it is true for day $1$, we know it is also true for day $m$\\
\item[3. ] $a_{m+1}(z) \geq a_m(g) \geq a_m(z)$\\ \\
The optimal hotel number we visit on day $m+1$ has to be $\geq$ the hotel number we visit on day $m$ with both the greedy and optimal approach. \\
\item[4. ] $a_{m+1} (g) \geq a_{m+1}(z)$\\ \\
This step shows us finally that for the entire solution, greedy does best.\\
\end{enumerate}
\end{solution}
\fi

\item[(b)] (6 points) Formally argue that this algorithm is correct using the
``Local Swap'' method. More concretely, given some hypothetical
optimal solution $Z$ of size $k$ and the solution $Z^*$ output by
greedy, define some solution $Z_1$ with the following two properties:
(1) $Z_1$ is no worse than $Z$; (2) $Z_1$ agrees with greedy in the
first day travel plan. After $Z_1$ is defined, define $Z_2$ s.t.: (1)
$Z_2$ is no worse than $Z_1$; (2) $Z_2$ agrees with greedy in the
first two days travel plan. And so on until you eventually reach
greedy.

\ifnum\me<2
\begin{solution}
\\
\begin{itemize}
\item[1. ] $Z_1$ picks the furthest we can go on day 1.  This can't be worse than the optimal, because it cannot be less then the optimal.  \\ \\
\item[2. ] $Z_1$ agrees with optimal because there is no further you can go for option 1 than the greedy so $Z_1$ agrees with greedy. \\ \\
\item[3. ] $Z_2$ First two days selected greedy wont be worse than the optimal because it is the furthest possible for 2 days, so it cannot be less than optimal.\\ \\
\item[4. ] $Z_2$ agrees with Optimal $Z$ because for the only 2 days that are different, we are picking the furthest we can go, which is the definition of optimal\\ \\
\item[5. ] $Z_k$ is the optimal.  We keep on moving one by one and see that with each replaced item, the greedy is the optimal.  For every element greedy replaced works as good as optimal, making it the optimal
\end{itemize}
\end{solution}
\fi

\end{itemize}

\newproblem{Fibonacci meets Huffman} {10 points}

Recall, Fibonacci numbers are defined by $f_0= f_1=1$ and $f_i =
f_{i-1} + f_{i-2}$ for $i\ge 2$.

\begin{itemize}
\item[(a)] (2 points) What is the optimal Huffman code for the following set
of frequencies which are the first $8$ Fibonacci numbers.
\ifnum\me<2
\begin{solution}
***************** INSERT PROBLEM \prob a SOLUTION HERE ***************
\end{solution}
\fi

\item[(b)] (4 points) Let $S_1 = 2  = f_0 + f_1$ and $S_i = S_{i-1} + f_i =
\ldots = f_i + f_{i-1} + \ldots f_1 + f_0$ (for $i>1$) be the sum of the
first $i$ Fibonacci numbers. Prove that $S_i = f_{i+2} -1$ for any $i\ge
1$.

\ifnum\me<2
\begin{solution}
***************** INSERT PROBLEM \prob b SOLUTION HERE ***************
\end{solution}
\fi

\item[(c)] (4 points) Generalize your solution to part (a) to find the shape of
the optimal Huffman code for the first $n$ Fibonacci numbers.
Formally argue that your tree structure is correct, by using part (b).

\ifnum\me<2
\begin{solution}
***************** INSERT PROBLEM \prob c SOLUTION HERE ***************
\end{solution}
\fi

\end{itemize}

\newproblem{Uninterrupted  Television}{14 Points}

Little Johnny is extremely fond of watching television. His parents
are off for work for the period $[S, F)$, and he wants to make full
use of this time by watching as much television as possible: in fact,
he wants to watch TV non-stop the entire period $[S;F)$.  He has a
list of his favorite $n$ TV shows (on different channels), where the
$i$-th show runs for the time period $[s_i,f_i)$, so that the union of
$[s_i,f_i)$ fully covers the entire time period $[S,F)$ when his
parents are away.


\begin{itemize}
\item[(a)] (10 points) Little Johnny doesn't mind to switch to the
  show already running, but is very lazy to switch the TV channels,
  and so he wants to find the smallest set of TV shows that he can
  watch, and still stay occupied for the entire period $[S,F)$. Design
  an efficient $O(n \log n)$ greedy algorithm to help Little Johny. Do
  not forget to carefully argue the correctness of your algorithm,
  using either the ``Greedy Always Stays Ahead'' or the ``Local Swap''
  argument.

\ifnum\me<2
\begin{solution}
***************** INSERT PROBLEM \prob a SOLUTION HERE ***************
\end{solution}
\fi


\item[(b)] (4 points). Assume now that Little Johnny will only watch
  shows from the beginning till end (except show starting before $S$
  or ending after $F$), but now he fetches another TV from the
  adjacent room, so that he can potentially watch up to two shows at a
  time. Can you find a strategy that will give the smallest set of TV
  shows that he can watch on the two TVs, so that at any time
  throughout the interval $[S,F)$ he watches at least one (and at most
  two) shows.  \hint{Try to examine your algorithm in part (a).}

\ifnum\me<2
\begin{solution}
***************** INSERT PROBLEM \prob b SOLUTION HERE ***************
\end{solution}
\fi

\end{itemize}


\end{document}
